# -*- coding: utf-8 -*-
"""Analise_Socioeconomica_Países.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SxjZO38FSCf2hAW6fOq3xR1pN7M-PhX3

### Análise Socioeconômica: Aprendizado Não Supervisionado

### Descrição do dataset

Para a realização do projeto, foi selecionada a base de dados do Subnational Human Development Index (SHDI), disponibilizada pelo Global Data Lab. Este dataset é particularmente adequado para uma análise socioeconômica via aprendizado não supervisionado, pois oferece uma visão do desenvolvimento humano em mais de 1.800 regiões subnacionais, abrangendo o período de 1990 a 2022.

A base detalha os três pilares do Índice de Desenvolvimento Humano (IDH), isto é, saúde, educação e renda, e inclui informações por gênero, o que fornece as múltiplas dimensões necessárias para que algoritmos não supervisionados possam identificar agrupamentos naturais, perfis socioeconômicos distintos e padrões de desigualdade regional que não seriam aparentes em uma análise de nível nacional.

O dataset contém indicadores sociais, econômicos e de desenvolvimento de 187 países ao todo. O objetivo é estudar e analisar desigualdades, desenvolvimento humano, condições de vida de diferentes regiões do mundo.
Significado das colunas:

**Identificadores Geográficos/Demográficos**

- `Country`: País
- `Continent`: Continente
- `ISO_Code`: O código de país de 3 letras
- `Level`: Se os dados se referem ao nível Nacional ou Subnacional (para uma região específica dentro do país)
- `GDLCODE`: Um código único do Global Data Lab (GDL) para identificar cada região específica.
- `Region`: O nome da região subnacional (aparece como Total quando a linha se refere aos dados do país inteiro).
- `Year`: O ano a que os dados se referem.
- `pop`: A população total (em milhões) da região ou país.

**Índices de Desenvolvimento Humano**

- `shdi` (Subnational Human Development Index): O Índice de Desenvolvimento Humano (IDH) para a região subnacional.
- `healthindex`: O componente de Saúde do IDH, calculado com base na expectativa de vida.
- `edindex`: O componente de Educação do IDH, calculado com base nos anos médios de escolaridade.
- `incindex` : O componente de Renda do IDH, calculado com base na Renda Nacional Bruta per capita.
- `sgdi` (Subnational Gender Development Index): O Índice de Desenvolvimento de Gênero, que compara o IDH das mulheres com o dos homens para medir a desigualdade de gênero.
- `shdif / shdim`: O IDH calculado especificamente para mulheres e homens.
- `healthindexf / healthindexm`: O índice de saúde para mulheres e homens.
- `edindexf / edindexm`: O índice de educação para mulheres e homens.
- `incindexf / incindexm`: O índice de renda para mulheres e homens.
- `lifexp`: Expectativa de vida ao nascer para a população total.
- `lifexpf / lifexpm`: Expectativa de vida para mulheres e homens.
- `msch`: Média de anos de escolaridade para a população total.
- `mschf / mschm`: Média de anos de escolaridade para mulheres e homens.

### Visualização do dataset
"""

# Estabelece conexão com o Google Drive.
from google.colab import drive
drive.mount("/content/drive")

import pandas as pd

# Cria um DataFrame, cujos dados são lidos do arquivo CSV "GDL-Custom-set-of-indicators-(2022)-data.csv".
df = pd.read_csv('/content/drive/MyDrive/GDL-Custom-set-of-indicators-(2022)-data.csv')

#df = pd.read_csv("GDL-Custom-set-of-indicators-(2022)-data.csv")

"""Existem 27 colunas no dataset, que foram comentadas uma a uma anteriormente."""

# Retorna as dimensões do DataFrame (quantidade de linhas, quantidade de colunas).
df.shape

# Visualizar o DataFrame.
display(df)

"""Detalhes sobre a natureza dos dados:"""

# Resume as informações do DataFrame, incluindo: número de linhas, número de colunas, nome e tipo das colunas, quantidade de valores não nulos.
df.info()

"""As variáveis do dataset, que tinham natureza categórica, como Country, Continent, ISO_Code e Region, que não são quantitativas, serão fundamentais para a interpretação dos resultados.

Há também variáveis numéricas, como os índices de desenvolvimento (shdi, healthindex, edindex, incindex), os indicadores brutos (lifexp, msch, pop) e suas versões por gênero.

As features possuem escalas muito diferentes, como a população que está na casa dos milhões e os índices que variam entre 0 e 1. Assim, essa disparidade justifica a etapa de pré-processamento, como a normalização, para garantir que todas as variáveis tenham um peso equivalente na análise não supervisionada.
"""

# Exibe estatísticas sobre as variáveis, como média, desvio padrão (variância), valor mínimo, quartis e valor máximo.
df.describe()

# Mostrar colunas numéricas do DataFrame original.
df_num = df.select_dtypes(include=['float64', 'int64']).dropna()
print("Colunas numéricas:", list(df_num.columns))

# Mostrar colunas categóricas (string) do DataFrame original.
df_cat = df.select_dtypes(exclude=['float64', 'int64'])
print("Colunas não numéricas:", list(df_cat.columns))

"""# Normalização de dados duplicados e/ou ausentes

# Dados  duplicados
"""

df.duplicated().sum()

df = df.drop_duplicates() #remove duplicatas exatas

df = df.drop(columns=["Year", "Region", "Level", "GDLCODE"]) # Remove colunas desnecessárias do dataframe

"""# Dados Nulos"""

df.isnull().sum() # Mostra a soma de valores nulos em cada coluna

cols_com_nulo = ['sgdi', 'shdif', 'shdim', 'healthindexf', 'healthindexm', 'edindexf', 'edindexm', 'incindexf', 'incindexm', 'lifexp', 'lifexpf', 'lifexpm', 'msch', 'mschf', 'mschm'] # Lista de nomes das colunas que serão preenchidas

df_preenchido = df.copy() # Cria uma cópia do DataFrame limpo para evitar modificar o original diretamente

for col in cols_com_nulo: # Inicia um loop que passará por cada nome de coluna na lista 'cols_com_nulo'
    df_preenchido[col] = df_preenchido.groupby('Continent')[col].transform(lambda x: x.fillna(x.mean())) # Agrupa por continente, calcula a média da coluna e preenche os valores nulos com essa média

# Passo de segurança: se algum valor ainda estiver nulo (ex: um continente inteiro sem dados), preenche com a média global
for col in cols_com_nulo: # Inicia outro loop pelas mesmas colunas para uma verificação final
    if df_preenchido[col].isnull().any(): # Se ainda existir algum valor nulo na coluna
        media_global = df_preenchido[col].mean() # media_global: Calcula a média geral da coluna
        df_preenchido[col].fillna(media_global, inplace=True) # Preenche os nulos restantes com a média geral

"""# Normalização"""

from sklearn.preprocessing import MinMaxScaler

# Selecionar apenas as colunas numéricas que fazem sentido normalizar
cols_numericas = df_preenchido.select_dtypes(include=['number']).columns.tolist() # cols_numericas: Cria uma lista com os nomes de todas as colunas que contêm números
cols_para_normalizar = [col for col in cols_numericas if col not in ['Year', 'pop']] # cols_para_normalizar: Cria uma nova lista, excluindo 'Year' e 'pop' da normalização

df_normalizado = df_preenchido.copy() # Cria uma cópia do DataFrame preenchido para a normalização
scaler = MinMaxScaler() # Cria um objeto (instância) do MinMaxScaler, que escalará os dados para o intervalo [0, 1]

# Aplicar a normalização (Min-Max Scaling)
df_normalizado[cols_para_normalizar] = scaler.fit_transform(df_preenchido[cols_para_normalizar]) # Aplica a normalização nas colunas selecionadas, reescrevendo-as com os valores entre 0 e 1
df = df_normalizado
df_normalizado.head() # Mostra as primeiras linhas do DataFrame normalizado

"""# Análise Exploratória

Iniciamos agora a segunda etapa do nosso projeto: a Análise Exploratória dos Dados. O objetivo principal desta fase é realizar uma investigação aprofundada sobre o conjunto de dados para extrair insights, compreender suas principais características, identificar padrões e formular as hipóteses que nortearão as fases subsequentes de modelagem.

Além disso, para realizar a nossa análise exploratória, faremos uso de duas bibliotecas de visualização do Python: matplotlib.pyplot e seaborn.
"""

import seaborn as sns
import matplotlib.pyplot as plt

"""## Análise de Correlação

A análise de correlação é um passo fundamental da análise exploratória para quantificar como as variáveis numéricas do conjunto de dados se relacionam. Ao calcular a matriz de correlação, conseguimos uma perspectiva acerca da relação linear entre cada par de variáveis.

### Matriz de Confusão
"""

df_numeros= df.select_dtypes(include=['number'])

plt.figure(figsize=(15, 12))
sns.heatmap(df_numeros.corr(), annot=True, linewidth=2, linecolor="white", fmt='.2f', annot_kws={'size': 8})
plt.show()

"""Aqui uma matriz de correlação foi criada para visualizar a relação linear entre as variáveis numéricas do conjunto de dados. Primeiro, o DataFrame foi pré-processado com o comando select_dtypes(include=['number']) para garantir que apenas as colunas numéricas fossem utilizadas. Além disso, a função .corr() calculou a correlação entre cada par dessas variáveis, usada na exibição do heatmap.

A análise da matriz de correlação revela uma conexão expressiva entre os principais pontos do desenvolvimento humano: saúde, educação e renda, que estão quase perfeitamente correlacionados com o IDH geral. Além disso, cabe mencionar que a população não demonstrou ter qualquer correlação linear com os indicadores de desenvolvimento a princípio. Dentre os resultados, algumas variáveis foram destaques como o grupo formado por lifexp (Expectativa de Vida), incindex (Índice de Renda) e edindex (Índice de Educação) com a relação expressiva com o índice principal, o shdi. Por outro lado, a variável pop (População) quase não teve correlação com os demais fatores, apesar de entendermos isso como um senso comum, então, possivelmente, uma hipótese contraintuitiva. Vale mencionar também a variável sgdi (Índice de Desenvolvimento de Gênero), que tem uma correlação mais moderada, o que aponta para uma dinâmica mais complexa.
"""

sns.clustermap(df_numeros.corr(), annot=True, fmt='.2f', cmap='coolwarm', linewidths=.8)
plt.show()

"""A análise desse gráfico, no caso outro heatmap, reafirma a formação dos blocos mencionados, como entre as varíaveis relacionadas ao desenvolvimento socioeconômico e educacional (shdi, incindex, edindex e etc). Além disso, existe um primeiro subgrupo contendo lifexp e healthindex, com as variáveis mais voltadas à saúde e a expectativa de vida. Ademais, a variável população, por exemplo, está separada, o que reforça a hipótese de que ela não possui uma relação linear relevante, neste dataset, com o desenvolvimento.

## Plotagem de Variáveis Únicas
"""

dados_2022 = df.copy()
sns.set_style("whitegrid")

#expectativa de vida
plt.figure(figsize=(10, 6))
sns.histplot(data=dados_2022, x='lifexp', kde=True, bins=20)
plt.title('Distribuição da Expectativa de Vida (lifexp) em 2022', fontsize=16)
plt.xlabel('Expectativa de Vida (Anos)', fontsize=12)
plt.ylabel('Frequência (Nº de Países)', fontsize=12)
plt.show()



plt.figure(figsize=(12, 7))
ordem_continentes = dados_2022['Continent'].value_counts().index
sns.countplot(data=dados_2022, y='Continent', order=ordem_continentes, palette='viridis')
plt.title('Contagem de Países por Continente em 2022', fontsize=16)
plt.xlabel('Número de Países', fontsize=12)
plt.ylabel('Continente', fontsize=12)
plt.show()

paises_outliers = dados_2022.sort_values(by='lifexp').head(10)
print("10 Países com Menor Expectativa de Vida (lifexp):")
print(paises_outliers[['Country', 'Continent', 'lifexp']])

#Saúde

plt.figure(figsize=(10, 6))
sns.histplot(data=dados_2022, x='healthindex', kde=True, bins=20)
plt.title('Distribuição do Índice de Saúde (healthindex) em 2022', fontsize=16)
plt.xlabel('Índice de Saúde (healthindex)', fontsize=12)
plt.ylabel('Frequência (Nº de Países)', fontsize=12)
plt.show()

plt.figure(figsize=(14, 8))
ordem_continentes_healthindex = dados_2022['Continent'].value_counts().index
sns.countplot(data=dados_2022, y='Continent', palette='plasma', order=ordem_continentes_healthindex)
plt.title('Contagem de Países por Continente com Dados de Índice de Saúde (healthindex) em 2022', fontsize=16)
plt.xlabel('Número de Países', fontsize=12)
plt.ylabel('Continente', fontsize=12)
plt.show()

paises_outliers_healthindex = dados_2022.sort_values(by='healthindex').head(10)
print("10 Países com Menor Índice de Saúde (healthindex):")
print(paises_outliers_healthindex[['Country', 'Continent', 'healthindex']])

#idh
plt.figure(figsize=(10, 6))
sns.histplot(data=dados_2022, x='shdi', kde=True, bins=20)
plt.title('Distribuição do IDH (shdi) em 2022', fontsize=16)
plt.xlabel('IDH (shdi)', fontsize=12)
plt.ylabel('Frequência (Nº de Países)', fontsize=12)
plt.show()

plt.figure(figsize=(14, 8))
ordem_continentes_shdi = dados_2022['Continent'].value_counts().index
sns.countplot(data=dados_2022, y='Continent', palette='plasma', order=ordem_continentes_shdi)
plt.title('Contagem de Países por Continente com Dados de IDH (shdi) em 2022', fontsize=16)
plt.xlabel('Número de Países', fontsize=12)
plt.ylabel('Continente', fontsize=12)
plt.show()

paises_outliers_shdi = dados_2022.sort_values(by='shdi').head(10)
print("10 Países com Menor IDH (shdi):")
print(paises_outliers_shdi[['Country', 'Continent', 'shdi']])

#educação
plt.figure(figsize=(10, 6))
sns.histplot(data=dados_2022, x='edindex', kde=True, bins=20)
plt.title('Distribuição do Índice de Educação (edindex) em 2022', fontsize=16)
plt.xlabel('Índice de Educação (edindex)', fontsize=12)
plt.ylabel('Frequência (Nº de Países)', fontsize=12)
plt.show()

plt.figure(figsize=(14, 8))
ordem_continentes_edindex = dados_2022['Continent'].value_counts().index
sns.countplot(data=dados_2022, y='Continent', palette='plasma', order=ordem_continentes_edindex)
plt.title('Contagem de Países por Continente com Dados de Índice de Educação (edindex) em 2022', fontsize=16)
plt.xlabel('Número de Países', fontsize=12)
plt.ylabel('Continente', fontsize=12)
plt.show()

paises_outliers_edindex = dados_2022.sort_values(by='edindex').head(10)
print("10 Países com Menor Índice de Educação (edindex):")
print(paises_outliers_edindex[['Country', 'Continent', 'edindex']])

#renda
plt.figure(figsize=(10, 6))
sns.histplot(data=dados_2022, x='incindex', kde=True, bins=20)
plt.title('Distribuição do Índice de Renda (incindex) em 2022', fontsize=16)
plt.xlabel('Índice de Renda (incindex)', fontsize=12)
plt.ylabel('Frequência (Nº de Países)', fontsize=12)
plt.show()

plt.figure(figsize=(14, 8))
ordem_continentes_incindex = dados_2022['Continent'].value_counts().index
sns.countplot(data=dados_2022, y='Continent', palette='plasma', order=ordem_continentes_incindex)
plt.title('Contagem de Países por Continente com Dados de Índice de Renda (incindex) em 2022', fontsize=16)
plt.xlabel('Número de Países', fontsize=12)
plt.ylabel('Continente', fontsize=12)
plt.show()

paises_outliers_incindex = dados_2022.sort_values(by='incindex').head(10)
print("10 Países com Menor Índice de Renda (incindex):")
print(paises_outliers_incindex[['Country', 'Continent', 'incindex']])

"""Nessa etapa, optamos por plotar as principais variáveis, os principais indicadores do desenvolvimento socioeconômico de um país, que seria a expectativa de vida, saúde, educação, renda e IDH(esse último que é uma síntese desses indicadores), e também analisar os outliers negativos. Podemos observar que o continente mais privilegiado é a Europa e América, pois possui médias altas e variações internas contidas. A Ásia e o Pacífico podem ser considerados medianos, pois graficamente apresentam tanto países com bons índices e países com índices ruins. Por fim, o continente africano nesse contexto é o mais abaixo, porque além de possuir as menores médias, contém variações relevantes, que traz a tona a desigualdade entre os países do continente.

## Gráficos de Dispersão

Nesta etapa, vamos visualizar a relação entre pares de variáveis numéricas através de gráficos de dispersão (scatterplot) para identificar tendências.

Os scatterplots são importantes para analisar este conjunto de dados, pois permitem explorar relações entre variáveis socioeconômicas e de desenvolvimento humano de forma visual e intuitiva.
"""

# Gráficos de dispersão (Scatterplot) que comparam o Índice de Desenvolvimento Humano (IDH)

sns.set_context("talk")

# Scatterplot: IDH (shdi) X Expectativa de Vida (lifexp)
plt.figure(figsize=(6, 7))
plt.title("IDH (shdi) e Expectativa de Vida (lifexp)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="shdi", y="lifexp", hue="Continent", palette="Set2", alpha=0.8)
plt.xlabel("Indice de Desenvolvimento Humano (IDH)", fontsize=12)
plt.ylabel("Expectativa de Vida (lifexp)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

# Scatterplot: IDH (shdi) X Média de Anos de Escolaridade (msch)
plt.figure(figsize=(6, 7))
plt.title("IDH (shdi) e Média de Anos de Escolaridade (msch)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="shdi", y="msch", hue="Continent", palette="Set2", alpha=0.8)
plt.xlabel("Indice de Desenvolvimento Humano (IDH)", fontsize=12)
plt.ylabel("Média de Escolaridade (msch)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

# Scatterplot: IDH (shdi) X Índice de Renda (incindex)
plt.figure(figsize=(4, 5))
plt.title("IDH (shdi) e Índice de Renda (incindex)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="shdi", y="incindex", hue="Continent", palette="Set2", alpha=0.8)
plt.xlabel("Indice de Desenvolvimento Humano (IDH)", fontsize=12)
plt.legend(title="Continente")
plt.ylabel("Renda (incindex)", fontsize=12)
plt.show()
print()

#Scatterplot: IDH (shdi) X População (pop)
plt.figure(figsize=(6, 7))
plt.title("IDH (shdi) e População em milhões (pop)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022[dados_2022["pop"] < 1000000], x="shdi", y="pop", hue="Continent", palette="Set2", alpha=0.8)
plt.xlabel("Indice de Desenvolvimento Humano (IDH)", fontsize=12)
plt.ylabel("População em milhões (pop)", fontsize=12)
plt.legend(title="Continente")
plt.show()

sns.set_context("notebook")

"""Ao observar os gráficos acima que relacionam o índice de Desenvolvimento Humano (IDH) (shdi) com outras variáveis, fica evidente, agora de maneira visual, a relação entre o IDH com a expectativa de vida, com a média de de anos de escolaridade e com a renda, porém no último gráfico é possível perceber a pouca relação entre o IDH e a população em milhões.

Observe que foi retirado deste último gráfico outliers, isto é, China e India cujo as populações são muito altas dificultando a análise do gráfico.

Com isso podemos concluir que países com baixo IDH tendem a ter baixa expectativa de vida, baixa escolaridade e baixa renda. O continente africano, é o continente com maior número de incidências de países com baixo IDH.
"""

# Gráficos de dispersão (Scatterplot) que comparam o Índice de Saúde (healthindex)

sns.set_context("talk")

plt.figure(figsize=(9, 8))
plt.title("Relação entre Saúde (healthindex) e Expectativa de Vida (lifexp)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="healthindex", y="lifexp", hue="Continent", palette="Set1", alpha=0.4)
plt.xlabel("Índice de Sáude (healthindex)", fontsize=12)
plt.ylabel("Expectativa de Vida (lifexp)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

plt.figure(figsize=(9, 8))
plt.title("Relação entre Saúde (healthindex) e Educação (edindex)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="healthindex", y="edindex", hue="Continent", palette="Set1", alpha=0.6)
plt.xlabel("Índice de Sáude (healthindex)", fontsize=12)
plt.ylabel("Índice de Educação (edindex)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

plt.figure(figsize=(9, 8))
plt.title("Relação entre Saúde (healthindex) e Renda (incindex)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="healthindex", y="incindex", hue="Continent", palette="Set1", alpha=0.6)
plt.xlabel("Índice de Saúde (healthindex)", fontsize=12)
plt.ylabel("Índice de Renda (incindex)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

plt.figure(figsize=(9, 8))
plt.title("Relação entre Saúde (healthindex) e População em milhões (pop)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022[dados_2022["pop"] < 1000000], x="healthindex", y="pop", hue="Continent", palette="Set1", alpha=0.6)
plt.xlabel("Índice de Saúde (healthindex)", fontsize=12)
plt.ylabel("População em milhões (pop)", fontsize=12)
plt.legend(title="Continente")
plt.show()

sns.set_context("notebook")

"""Esses 4 gráficos estão relacionando o Índice de Saúde (healthindex) com outras variáveis.

O primeiro gráfico mostra a forte correlação entre as variáveis Índice de Saúde (healthindex) e a Expectativa de Vida (lifexp).

Os 2 gráficos seguintes demonstram uma relação da sáude de um país com a educação e a renda do mesmo, respectivamente, em uma tendência positiva.

Ficando claro que países com melhor sáude, os europeus em sua maioria, tem maior renda, educação e expectativa de vida.

Por outro lado, quase não há relação da saúde com a população.

OBS: Foram retirados do útltimo gráfico países com população muito discrepante dos outros países, isto é, India e China.
"""

# Gráficos de dispersão (Scatterplot) que comparam o Índice de Educação (edindex)

sns.set_context("talk")

plt.figure(figsize=(9, 8))
plt.title("Relação entre Educação (edindex) e Expectativa de Vida (lifexp)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="edindex", y="lifexp", hue="Continent", palette="Set3")
plt.xlabel("Índice de Educação (edindex)", fontsize=12)
plt.ylabel("Expectativa de Vida (lifexp)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

plt.figure(figsize=(9, 8))
plt.title("Relação entre Educação (edindex) e Renda (incindex)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022, x="edindex", y="incindex", hue="Continent", palette="Set3")
plt.xlabel("Índice de Educação (edindex)", fontsize=12)
plt.ylabel("Índice de Renda (incindex)", fontsize=12)
plt.legend(title="Continente")
plt.show()
print()

plt.figure(figsize=(9, 8))
plt.title("Relação entre Educação (edindex) e População em milhões (pop)", fontsize=16, weight="bold")
sns.scatterplot(data=dados_2022[dados_2022["pop"] < 1000000], x="edindex", y="pop", hue="Continent", palette="Set3")
plt.xlabel("Índice de Educação (edindex)", fontsize=12)
plt.ylabel("População em milhões (pop)", fontsize=12)
plt.legend(title="Continente")
plt.show()

sns.set_context("notebook")

"""Agora olhando para o Índice de Educação, temos:

Educação x Expectativa de vida (edindex vs lifexp):
Mostra uma relação positiva entre educação e expectativa de vida.

Educação x Renda (edindex vs incindex):
Mostra se melhor desempenho educacional se traduz em maior renda média.
Em geral, há uma tendência positiva, mas nem sempre perfeita — isso permite ver ineficiências econômicas: países bem educados que ainda não conseguem transformar isso em riqueza.
O que pode significar que desigualdades econômicas podem persistir mesmo com avanços na educação.

Educação x População (edindex vs pop):
Não há muita relação entre a educação e a população de um país.

OBS: Foram retirados desse gráfico países com população muito discrepante dos demias países, isto é, China e India.

Em resumo, os gráficos que relacionam o índice de educação com outras variáveis ajudam a:
Detectar correlações estruturais entre educação, renda, saúde e desenvolvimento;
Identificar anomalidades (ex.: alta renda mas educação baixa);
Fundamentar políticas públicas integradas em educação, saúde e economia.

## Box Plots Comparativos

Agora, analisaremos os gráficos de caixa que mais fazem sentido com a proposta e que nos possibilita ter uma visão crítica sobre os fatores socioeconômicos.
"""

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='pop', color='#8A2BE2', linecolor="purple")
plt.title("Comparação entre Continente e População")
plt.xlabel("Continente")
plt.ylabel("População")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='edindex', color='#8A2BE2', linecolor="purple")
plt.title("Comparação entre Continente e Educação")
plt.xlabel("Continente")
plt.ylabel("Educação")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='edindexf', color='darkorange', linecolor="orange")
plt.title("Comparação entre Continente e Educação Feminina")
plt.xlabel("Continente")
plt.ylabel("Educação feminina")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='edindexm', color='limegreen', linecolor="green")
plt.title("Comparação entre Continente e Educação Masculina")
plt.xlabel("Continente")
plt.ylabel("Educação Masculina")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='healthindex', color='#8A2BE2', linecolor="purple")
plt.title("Comparação entre Continente e Saúde")
plt.xlabel("Continente")
plt.ylabel("Saúde")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='incindex', color='#8A2BE2', linecolor="purple")
plt.title("Comparação entre Continente e Renda")
plt.xlabel("Continente")
plt.ylabel("Renda")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='incindexf', color='darkorange', linecolor="orange")
plt.title("Comparação entre Continente e Renda Feminina")
plt.xlabel("Continente")
plt.ylabel("Renda Feminina")
plt.show()

plt.figure(figsize=(10, 10))
sns.boxplot(data=df.head(20), x='Continent', y='incindexm', color='limegreen', linecolor="green")
plt.title("Comparação entre Continente e Renda Masculina")
plt.xlabel("Continente")
plt.ylabel("Renda Masculina")
plt.show()

"""As comparações foram realizadas entre os continentes para facilitar a visualização dos dados. Dessa forma, foi possível observar os níveis de educação, saúde e renda, bem como as diferenças de gênero nos cinco continentes.

## Análise de frequência e relação entre variáveis categóricas
"""

# Frequência de cada valor das variáveis.
import pandas as pd

# Cada país, GDLCODE e código ISO aparece apenas uma vez no dataframe -> frequências serão todas iguais.
variaveis_categoricas = ['Country', 'Continent', 'ISO_Code']

for var in variaveis_categoricas:
    if var in ['Country', 'ISO_Code']:
      continue
    pct = df[var].value_counts(normalize=True) * 100
    print(f"Frequência relativa de {var} (em %):")
    print(pct.round(2))
    print()

# Teste de relação estatística -> qui-quadrado.

# Se p < 0.05, há relação significativa entre as variáveis.

from scipy.stats import chi2_contingency

tabela = pd.crosstab(df['Continent'], df['Country'])
chi2, p, dof, expected = chi2_contingency(tabela)
print(f"Qui-quadrado = {chi2:.3f}, p-valor = {p:.4f}")

"""No teste de relação entre Continente e País, obtivémos qui-quadrado alto (0.4564). Isso indica que existe alta correlação entre essas variáveis, como era de se esperar.

## Histogramas e Gráficos de Densidade

Essa seção tem como objetivo visualizar a forma da distribuição das principais variáveis numéricas através de histogramas e outros gráficos de densidade
"""

# População em milhões
plt.title("População em Milhões (pop)")
plt.xlabel("População (pop)")
plt.ylabel("Frequência")
sns.histplot(data=df, x='pop', kde=True)

# População em milhões por continente
plt.title("População em Milhões (pop) por Continente")
plt.xlabel("População (pop)")
plt.ylabel("Frequência")
sns.kdeplot(data=df, x="pop", hue="Continent", palette="Set2")

# População em milhões desconsiderando China e India (Outliers)
plt.title("População em Milhões (pop sem outliers)")
plt.xlabel("População (pop)")
plt.ylabel("Frequência")
sns.histplot(data=df[df["pop"] < 1000000], x='pop', kde=True)

# População em milhões desconsiderando China e India (Outliers)
plt.title("População em Milhões (pop sem outliers) por Continente")
plt.xlabel("População (pop)")
plt.ylabel("Densidade")
sns.kdeplot(data=df[df["pop"] < 1000000], x="pop", hue="Continent", palette="Set2")

# Saúde
plt.title("Saúde (healthindex)")
plt.xlabel("Índice de Saúde (healthindex)")
plt.ylabel("Frequência")
sns.histplot(data=df, x='healthindex', kde=True)

# Sáude por continente
plt.title("Saúde (healthindex) por Continente")
plt.xlabel("Índice de Saúde (healthindex)")
plt.ylabel("Densidade")
sns.kdeplot(data=df, x="healthindex", hue="Continent", palette="Set2")

# Educação
plt.title("Educação (edindex)")
plt.xlabel("Índice de Educação (edindex)")
plt.ylabel("Frequência")
sns.histplot(data=df, x='edindex', kde=True)

# Educação por continente
plt.title("Educação (edindex) por Continente")
plt.xlabel("Índice de Educação (edindex)")
plt.ylabel("Densidade")
sns.kdeplot(data=df, x="edindex", hue="Continent", palette="Set2")

# Renda
plt.title("Renda (incindex)")
plt.xlabel("Índice de Renda (incindex)")
plt.ylabel("Frequência")
sns.histplot(data=df, x='incindex', kde=True)

# Renda por continente
plt.title("Renda (incindex) por Continente")
plt.xlabel("Índice de Renda (incindex)")
plt.ylabel("Densidade")
sns.kdeplot(data=df, x="incindex", hue="Continent", palette="Set2")

"""A partir desses gráficos, não há muito a se adicionar além do já observado até aqui: os continentes mais desenvolvidos economicamente possuem estatísticas sólidas e acima da média(como Europa e América), enquanto os dados dos outros continentes se comportam de maneira instável e com poucas amostras acima da média(Ásia e principalmente África)

## Pair Plots
"""

variaveis_numericas = ['Year', 'shdi', 'healthindex', 'edindex', 'incindex', 'sgdi', 'shdif', 'shdim', 'healthindexf', 'healthindexm', 'edindexf', 'edindexm', 'incindexf', 'incindexm', 'lifexp', 'lifexpf', 'lifexpm', 'msch', 'mschf', 'mschm', 'pop']

variaveis_para_plotar = [v for v in variaveis_numericas if v != 'Year']

sns.pairplot(df[variaveis_para_plotar])
plt.show()

"""A análise do pairplot revela relações significativas entre as variáveis do conjunto. No caso, o padrão mais notável é a existência de correlações lineares positivas entre a grande maioria das variáveis, o que indica uma alta interdependência entre métricas como os índices de desenvolvimento humano, saúde, educação e renda.

Por outro lado, a variável referente à população demonstrou um comportamento diferente, pois, ao contrário das demais, não apresentou uma correlação linear clara com os outros índices, o que, pode indicar que o crescimento populacional não acompanha linearmente a evolução dos indicadores de desenvolvimento.

Além disso, a análise da variável população permitiu a identificação de outliers muito distantes do agrupamento principal, que representam observações com valores de população extremamente altos, cujo comportamento se desvia notavelmente do padrão geral do conjunto de dados.

Essa seção revela visualmente que as diferentes perspectivas do desenvolvimento humano são profundamente interligadas. É praticamente impossível encontrar um país que seja excelente em educação, mas péssimo em saúde, ou rico, mas com baixa expectativa de vida. Os dados mostram que o progresso é um fenômeno holístico.

# Análise das medidas descritivas

Antes de explorar as complexas relações entre as variáveis com os algoritmos que serão aplicados, vale dedicar esta seção à estatística descritiva com algumas medidas de tendência central básicas e medidas de dispersão.
"""

df.describe()

# Calcula a moda de todas as features, com exceção das colunas que tem muitos, ou só tem, valores únicos

for column in df.columns:
    if column not in ['Country', 'Year', 'ISO_Code', 'pop']:
        moda = df[column].mode()
        print(f"Coluna: {column}")
        print(f"{moda.to_string(index=True)}\n" + "\n")

colunas_redundantes = ['Country', 'ISO_Code', 'Continent']
df_coeficiente = df.drop(columns=colunas_redundantes)

# Para calcular o coeficiente de variação: Desvio Padrão / Média
coeficiente_variacao = df_coeficiente.std() / df_coeficiente.mean()

print(coeficiente_variacao)

colunas_redundantes = ['Country', 'ISO_Code', 'Continent']
df_assimetria = df.drop(columns=colunas_redundantes)

assimetria = df_assimetria.skew()

print(" Assimetria (Skewness) para cada Variável\n")
print(assimetria)

"""# Hipóteses Iniciais

**1. Hipótese sobre a população:**

No geral, o IDH e o índice de saúde são determinados mais pela distribuição de riqueza do que pelo tamanho da população. Ou seja, podemos dizer que países superpopulosos não apresentam necessariamente níveis baixos na educação e na saúde, baixa expectativa de vida e IDH. Da mesma forma, países com uma população menor não apresentam bons índices.

**2. Hipótese sobre saúde e expectativa de vida:**

Pode parecer óbvio, mas cabe destacar que as variáveis *lifexp* (expectativa de vida) e *healthindex* (saúde) são reflexos uma da outra e isso é explicitado nos *gráficos de dispersão*.

**3. Hipótese sobre diferença de gênero:**

Nos *gráficos de boxplot*, é possível comparar as diferenças entre gêneros e, com isso, levantar a hipótese de que os continentes com índices de renda e educação mais baixos são os que apresentam a diferença mais significativa entre homens e mulheres (com destaque para África e Américas). Isto é, os continentes menos desenvolvidos financeira e educacionalmente são justamente aqueles em que as mulheres são mais afetadas.

**4. Hipótese sobre educação e renda:**

Mais uma vez, parece óbvio, porém é perceptível nos gráficos a relação entre *edindex* (educação) e *incindex* (renda). Assim, podemos dizer que a educação afeta significativamente o índice de renda de um país.

**5. Hipótese sobre a semelhança entre África e América:**

Observa-se uma semelhança nos níveis de desenvolvimento entre esses dois continentes, impulsionada principalmente por um alto grau de desigualdade de renda, além de níveis preocupantes em educação, saúde e equidade de gênero. Porém, é importante destacar que a semelhança não se dá entre a África e a América como um todo, mas sim entre a África e a parte em desenvolvimento da América.

# Aplicação do Algoritmo

## Preparação final dos dados:

Para validar as hipóteses levantadas durante a análise exploratória, adotaremos uma abordagem comparativa, criando três "modelos" de clusterização distintos. O primeiro, o Modelo Base, utilizará os pilares centrais do desenvolvimento (healthindex, edindex, incindex, lifexp) para estabelecer uma linha de base de como os países se agrupam puramente por seu nível de desenvolvimento. Em seguida, o Modelo de Desigualdade (testando a Hipótese 5 da seção anterior), relaciona o Índice de Desenvolvimento Humano para as regiões subnacional (shdi) e a média de anos de escolaridade (msch) com os indicadores do Modelo Base. Por fim, o Modelo de Gênero (testando a Hipótese 3) incluirá as colunas de disparidade (incindexf, incindexm) para avaliar o impacto das lacunas de gênero na formação dos clusters. Ao comparar os resultados desses três modelos, poderemos observar quais features têm maior poder de definição e validar (ou refutar) nossas hipóteses iniciais.

Além disso, cabe ressaltar que uma etapa adicional de padronização (como o StandardScaler, que ajusta os dados para terem média 0 e desvio padrão 1) não é necessária e seria, na verdade, redundante. No caso, o propósito fundamental de escalar os dados antes de algoritmos baseados em distância (como o K-Means) é garantir que todas as features contribuam equitativamente para o cálculo, evitando que variáveis com amplitudes maiores dominem o resultado, mas esse objetivo já foi alcançado pela aplicação do MinMaxScaler na etapa anterior de normalização, que colocou todas as colunas numéricas em um intervalo comum de [0, 1].

### Modelo Base
"""

features_colunas = ['healthindex', 'edindex', 'incindex', 'lifexp']
df_algoritmo_base = df[features_colunas]
display(df_algoritmo_base.head())

"""### Modelo Desigualdade"""

features_desigualdade = ['healthindex', 'edindex', 'incindex', 'lifexp', 'shdi', 'msch']
df_algoritmo_desigualdade = df[features_desigualdade]
display(df_algoritmo_desigualdade.head())

"""### Modelo Gênero"""

features_genero = ['healthindex', 'edindex', 'incindex', 'incindexf', 'incindexm', 'healthindexf', 'healthindexm', 'edindexf', 'edindex']
df_algoritmo_genero = df[features_genero]
display(df_algoritmo_genero.head())

"""### Número de clusters para Modelo Gênero"""

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_padronizado = scaler.fit_transform(df[features_genero])
from sklearn.cluster import KMeans

scaler = StandardScaler()
X_padronizado = scaler.fit_transform(df[features_genero])

# Método do cotovelo
wss = []
K = range(1, 11)  # número de clusters a testar

for k in K:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(X_padronizado)
    wss.append(kmeans.inertia_)

# Gráfico do método do cotovelo
plt.plot(K, wss, 'o-', color='purple')
plt.grid(True)
plt.xlabel('Nº de clusters (k)')
plt.ylabel('Soma de distâncias internas (WSS)')
plt.title('Método do cotovelo - Modelo Gênero')
plt.show()

"""- Ideal: K 3
- Justificativa: Há uma queda muito grande de 1 a 2, da mesma forma que a partir do K3 a curva começa a achatar, ideal: k3.

### Número de clusters para Modelo Base
"""

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_padronizado = scaler.fit_transform(df[features_colunas])

plt.plot(K, wss, 'o-', color='green')
plt.grid(True)
plt.xlabel('N° de clusters (k)')
plt.ylabel('Soma de distâncias internas (WSS)')
plt.show()

"""### Número de clusters para Modelo Desigualdade"""

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_padronizado = scaler.fit_transform(df[features_desigualdade])

plt.plot(K, wss, 'o-', color='red')
plt.grid(True)
plt.xlabel('N° de clusters (k)')
plt.ylabel('Soma de distâncias internas (WSS)')
plt.show()

"""Podemos ver que o número ideal é o mesmo para os três modelos, isso indica que os padrões de agrupamento são semelhantes. Como vimos antes que as features estão fortemente correlacionadas entre si, assim, o k3 é o ideal.

## Aplicação do K-Means: treinamento e agrupamento
"""

print(df_normalizado.columns)

from sklearn.cluster import KMeans
k_otimo = 3

# Selecionar apenas atributos numéricos.
df_normalizado_num = df_normalizado[['shdi', 'healthindex', 'edindex', 'incindex', 'sgdi', 'shdif', 'shdim', 'healthindexf', 'healthindexm', 'edindexf', 'edindexm', 'incindexf', 'incindexm', 'lifexp', 'lifexpf', 'lifexpm', 'msch', 'mschf', 'mschm', 'pop']]
df_normalizado_num = df_normalizado_num.dropna()

# Modelo base.
kmeans_base = KMeans(n_clusters=k_otimo, random_state=42, n_init=10)
kmeans_base.fit(df_normalizado_num[features_colunas])

# Modelo de Desigualdade
kmeans_desigualdade = KMeans(n_clusters=k_otimo, random_state=42, n_init=10)
kmeans_desigualdade.fit(df_normalizado_num[features_desigualdade])

# Modelo de Gênero
kmeans_genero = KMeans(n_clusters=k_otimo, random_state=42, n_init=10)
kmeans_genero.fit(df_normalizado_num[features_genero])

# O Canada está sendo removido, pois, foi retirado na célula acima "df_normalizado_num = df_normalizado_num.dropna()" e está dando imcompatibilidade com o número de linhas do df
df = df[df["Country"] != "Canada"]

# Modelo Base
df["Base"] = kmeans_base.labels_
print(df['Base'].value_counts(), "\n") # Contagem de países por cluster

# Modelo de Desigualdade
df["Desigualdade"] = kmeans_desigualdade.labels_
print(df['Desigualdade'].value_counts(), "\n")

# Modelo de Gênero
df["Genero"] = kmeans_genero.labels_
print(df['Genero'].value_counts(), "\n")

"""## PCA"""

from sklearn.decomposition import PCA

# Cria a instância do PCA com 2 componentes principais
pca = PCA(n_components=2)

from sklearn.decomposition import PCA
pca = PCA(n_components=2)
pca_resultado = pca.fit_transform(df_normalizado_num)
df_pca = pd.DataFrame(
    pca_resultado,
    columns=['PC1', 'PC2'],
    index=df_normalizado_num.index
)
df_pca['Base'] = df['Base'].values
df_pca['Desigualdade'] = df['Desigualdade'].values
df_pca['Genero'] = df['Genero'].values
print(df_pca.head())
##O código usa fit_transform() do PCA dos mesmos dados padronizados usados no K-Means (Etapa 1), reduzindo a dimensionalidade do conjunto para dois componentes principais (PC1 e PC2).
##Isso nos leva a visualização da distribuição dos países em um espaço bidimensional, mantendo o máximo possível da variância original dos dados.
##Depois, as labels dos clusters obtidas pelos modelos Base, Desigualdade e Gênero foram adicionadas, facilitando análises.

# Adicionando a coluna 'Country'
df_pca['Country'] = df['Country'].copy()

# Adicionando a coluna 'Continent'
df_pca['Continent'] = df['Continent'].copy()

# Verificando o resultado final
print(df_pca.head())

"""

---

# Visualização dos Clusters 2D"""

#estilo visual para os gráficos
sns.set_style("whitegrid")

#modelo base

plt.figure(figsize=(12, 8))
sns.scatterplot(
    data=df_pca,
    x='PC1',
    y='PC2',
    hue='Base',
    palette='viridis',
    s=100,
    alpha=0.7
)
plt.title('Visualização dos Clusters (Modelo Base) - PCA', fontsize=16)
plt.xlabel('Componente Principal 1 (PC1)', fontsize=12)
plt.ylabel('Componente Principal 2 (PC2)', fontsize=12)
plt.legend(title='Cluster Base')
plt.grid(True)
plt.show()


#modelo de desigualdade

plt.figure(figsize=(12, 8))
sns.scatterplot(
    data=df_pca,
    x='PC1',
    y='PC2',
    hue='Desigualdade',
    palette='coolwarm',
    s=100,
    alpha=0.7
)
plt.title('Visualização dos Clusters (Modelo Desigualdade) - PCA', fontsize=16)
plt.xlabel('Componente Principal 1 (PC1)', fontsize=12)
plt.ylabel('Componente Principal 2 (PC2)', fontsize=12)
plt.legend(title='Cluster Desigualdade')
plt.grid(True)
plt.show()


#modelo de gênero
plt.figure(figsize=(12, 8))
sns.scatterplot(
    data=df_pca,
    x='PC1',
    y='PC2',
    hue='Genero',
    palette='plasma',
    s=100,
    alpha=0.7
)
plt.title('Visualização dos Clusters (Modelo Gênero) - PCA', fontsize=16)
plt.xlabel('Componente Principal 1 (PC1)', fontsize=12)
plt.ylabel('Componente Principal 2 (PC2)', fontsize=12)
plt.legend(title='Cluster Gênero')
plt.grid(True)
plt.show()

"""Ao visualizar esses três clusters em um gráfico 2D usando PCA, confirmamos que os grupos são estatisticamente bem definidos e claramente separados. A análise mostra que o principal fator que define os clusters é o "Nível de Desenvolvimento Geral" de um país. Em suma, a clusterização provou que as diferentes facetas do desenvolvimento (saúde, educação, renda, gênero) são tão interligadas que, na prática, se movem em bloco, permitindo agrupar o mundo de forma coesa em três níveis de desenvolvimento.

## Interpretação dos Clusters
"""

# Base
df[['healthindex', 'edindex', 'incindex', 'lifexp', 'Base']].groupby('Base').mean()

"""**Base** -
A partir do gráfico e da tabela acima, a divisão dos clusters, mostra a seguinte separação:

Cluster 0: Países com baixo desenvolvimento e com baixos valores nos índices socioeconômicos.

Cluster 1: Países com alto desenvolvimento e com altos valores nos índices socioeconômicos.

Cluster 2: Países com médio desenvolvimento e com médios valores nos índices socioeconômicos.
"""

# Desigualdade
df[['healthindex', 'edindex', 'incindex', 'lifexp', 'shdi', 'msch', 'Desigualdade']].groupby('Desigualdade').mean()

"""**Desigualdade** -
A partir do gráfico e da tabela acima, a divisão dos clusters, mostra a seguinte separação:

Cluster 0: Países com baixo desenvolvimento e grande desigualdade.

Cluster 1: Países com desenvolvimento médio e com desigualdade moderada.

Cluster 2: Países com alto desenvolvimento e com pouca desigualdade.
"""

# Gênero
df[['healthindex', 'edindex', 'incindex', 'incindexf', 'incindexm', 'healthindexf', 'healthindexm', 'edindexf', 'edindex', 'Genero']].groupby('Genero').mean()

"""**Gênero** -
A partir do gráfico e da tabela acima, a divisão dos clusters, mostra a seguinte separação:

Cluster 0: Desenvolvimento médio com diferenças moderadas entre gêneros.

Cluster 1: Desenvolvimento baixo e desigual entre gêneros.

Cluster 2: Desenvolvimento alto e mais equitativo entre os gêneros.
"""

df.to_csv('dados.csv', index=False)